# 运输层

[toc]

## 3.1 概述和运输层服务

0. 运输层协议**为运行在不同主机上的应用进程提供逻辑通信服务**，在端系统中实现

### 3.1.1 运输层和网络层的关系

### 3.1.2 因特网运输层概述

0. UDP：用户数据报协议
1. TCP：传输控制协议
2. 运输层报文段：报文段 Segment

## 3.2 多路复用与多路分解

1. 多路复用和多路分解是将网络层所提供的**主机到主机交付服务**扩展到为在主机上运行的应用程序所提供的**进程到进程的交付服务**。
2. 在目的主机，传输层从邻接其下的网络层接收报文段。**运输层负责将这些报文段中的数据交付给主机上运行的合适的应用进程**。
3. 套接字：享受网络服务的进程有一个到多个套接字（唯一标识），相当于网络向进程和进程向网络传递数据的门户。接收主机中的运输层实际上并没有将数据直接交付给进程，而是通过一个中间的套接字来传递。
4. **多路分解**：传输层检查报文段中的特定字段并标识出接收套接字，然后将报文段定向到该套接字；**将传输层报文段中的数据交付到正确的套接字的工作**。
5. **多路复用**：**从源主机的不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层的工作**。
6. 源端口号字段和目的端口号字段：端口号是16比特的，范围从**0~65535**之间，0~1023称为周知端口号
7. 一个**UDP套接字是由一个包含目的IP和目的端口号的二元组来全面标识的**；而**TCP套接字是通过一个四元组（源IP、源端口号、目的IP、目的端口号）来标识的**，与UDP不同的是，两个不同源IP地址或源端口号的到达的TCP报文段将会被定向到两个不同的套接字，除非TCP携带了初始创建连接的请求。
8. Web服务器与TCP：连接套接字与进程间并非总是一一对应的，而是每有一个连接创建一个线程。

## 3.3 无连接传输：UDP

1. 除了多路复用、多路分解和一些轻型的差错检测外，UDP几乎没有对IP增加别的东西。

2. 选用UDP的部分原因：应用层能更好地控制要发送的数据和发送时间、无需建立连接、无需维护连接状态、分组首部开销小。

###  3.3.1 UDP报文段结构  

3. 首部有四个字段（源端口号、目的端口号、长度、检验和），每个字段两个字节。

### 3.3.2 UDP检验和

4. 检验和：一种端到端的基础上在运输层提供差错检测。

5. 检验和计算方法：发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出被回卷（回卷就是最高位的进位送到最低位，然后最低位又开始往高位进位（如果有新的进位的话）。

6. 检验和的验证过程：接收方负责把所有16个比特字（包括校验和）回卷加在一起，如果无差错则求得的和是16个1，否则出错。

## 3.4 可靠数据传输的原理

1. RDT: Reliable Data Transfer 可靠数据传输
2. ARQ: Automatic Repeat reQuest 自动重传请求
3. 停等协议: Stop-and-Wait ，停等下发送方的利用率很低。

### 3.4.1 构造可靠数据传输协议

4. 非流水线下：可靠传输协议是一个**停等协议**，即一个包传输成功后，下一个包才能开始传输，引入的协议要点：**检验和、序号、定时器、肯定确认**（冗余ACK），能够解决比特差错和丢包，状态机可参考P144 rdt3.0 。

### 3.4.2 流水线可靠数据传输协议

5. **解决流水线的差错恢复**的两种基本方法：**回退N步和选择重传**，使用的机制总结：检验和、定时器、序号、累计确认、**窗口**和流水线。

### 3.4.3 回退N步（Go-Back-N，GBN）

6. 窗口：N为窗口长度，那些**已经被发送但还未被确认的许可序号范围**可以看成是一个在序号范围内长度为N的窗口，GBN又称滑动窗口协议，窗口内包含**待确认的分许序号**（**从”基序号“到“下一个序号“**）和可以**被立即发送的分组序号**（**从”下一个序号“到”基序号+N-1“**）。
7. 分组序号：32位，范围从0到2^32-1，其中序号是**按照字节流中的字节计数**的而不是按分组数目计数的。
8. 发送方：
   1. 上层想要发送时，先检查窗口是否已满，未满则创建分组并发送，同时更新窗口；
   2. 收到ACK时，对序号为n的分组的确认采取**累积确认**（**表明已收到该序号以前的所有分组**）；
   3. 超时事件：发送方将**重发所有已发送但未确认的分组**，重启计时器。
9. 接收方：
   1. 若分组号为n的收到了，且上一个收到的是n-1，则**发送ACK**，否则丢弃该分组，并为最近已收到的分组重传ACK。
   2. 即接收方**不需要缓存任何失序分组**。

### 3.4.4 选择重传（SR）

10. 选择重传协议通过让发送方仅重传那些**它怀疑**出错的分组，同样使用窗口来限制流水线中未完成、未被确认的分组，在SR下，**发送方的窗口中已确认的可以不是连续的。发送方的窗口和接受方的窗口并不总是一致的。**
11. 发送方：
    1. 上层发送数据时，SR检查下一个可用于分组的序号，若序号在窗口内则发送；
    2. 超时：**每个分组都必须有自己的逻辑定时器**，超时后只发送一个分组；
    3. 收到ACK后，若接收到的序号**在窗口内则对其进行标记**，**窗口基序号向前移动到具有最小序号的未确认分组处**，发送窗口移动后可发送的分组。
12. 接收方：
    1. 接收方接收分组而不管是否按序，失序的分组将被缓存直至所有比它序号小的分组都收到。
    2. 窗口内的序号的分组都能接收并缓存，一个选择ACK被发送回发送方，在此情况下，若接受的序号等于接收窗口的基序号，则将分组及以前缓存的分组交付给上层（可以大于该分组基序号，但要求连续），窗口按交付的数量向前移动。
    3. **序号在接收基序号之前的分组被收到时，必须产生ACK，即便已经确认过该分组**（不然发送方的窗口无法向前移动）。
13. 对于SR协议，**窗口长度必须小于等于序号空间大小的一半**，否则可能会出现不知道是新分组还是重传的情况。
14. 分组重新排序：排序时可能出现不在窗口内的分组的缓存，为避免此冗余分组，需要确保序号不会被重用、可设定分组寿命：一个分组在网络中存在的时间不超过某个上限。

## 3.5 面向连接的运输：TCP

### 3.5.1 TCP连接

1. TCP提供全双工服务，并且是点对点的，由客户机发起连接，因为是传输层，主机间的网络要素（路由器、交换机、中继器）没有为其连接分配缓存和变量。
2. MMS：最大报文段长（TCP从缓存中去除并放入报文段的数据量受限于MSS，MSS通常根据最初确定的最大链路层帧长度来设置），MTU：最大传输单元（不包括TCP首部的长度）

### 3.5.2 TCP报文段结构

3. 由首部字段（一般是20字节）和数据字段组成，首部包含的字段包括：源端口号、目的端口号，验证和字段、32比特的**序号字段**和32比特的**确认号字段**，16比特的接收窗口字段、4比特首部长度字段、6比特标志字段（ACK：确认字段, URG：指示报文段里存在着被发送方的上层实体设置为紧急的数据, PSH：指示接收方应立即将数据交付给上层、RST, SYN, FIN：后三个用于连接的建立和拆除）、16位紧急指针和可选与边长的选项字段。

4. 序号(Seq)字段：指该**报文段首字节的字节流编号**；确认号(ACK)字段：**主机期望从另一个主机收到的下一个字节的序号**。

   例子：**A已收到B发来的前535个字节，同时假设A要发一个报文段给B，因此主机A会在发往B的报文段的确认号中填536**（并遵循累计确认）。

5. 捎带：在计算机通信中，当一个数据帧到达的时候，接收方并不是立即发送一个单独的控制帧，而是抑制一下自己并且开始等待，直到网络层传递给它下一个分组。然后，确认信息被附在往外发送的数据帧上。将确认暂时延迟以便可以钩到下一个外发数据帧。

### 3.5.3 往返时延的估计与超时

6. 估计往返时延：报文的样本RTT是从某报文段被发出到对该报文是确认被收到之间的时间量，TCP维持一个SampleRTT均值（EstimatedRTT），并随着新获取的SampleRTT更新，更新方式如下：

   **EstimatedRTT = (1 - alpha) times EstimatedRTT + alpha times SampleRTT**

   其中 alpha 的参考值是0.125。

   RTT偏差DevRTT用于估计SampleRTT一般会偏移EsitimatedRTT的程度：

   **DevRTT = (1 - beta) times DevRTT + beta times |SampleRTT - EstimatedRTT| **

7. 设置和管理重传超时间隔：

   **TimeoutInterval = EstimatedRTT + 4 times DevRTT**

### 3.5.4 可靠数据传输

8. 累计确认：TCP确认是累计式的，正确接收单失序的报文段是不会被接收方逐个确认的。例如接收端返回ACK=80，则证明报文80以及之前的报文段都被正确接收。并且，TCP发送方仅需维持已发送单位被确认的最小序号和下一个要发送的字节序号。这一点采用的是GBN的实际思路。

9. 缓存失序分组：许多TCP实现会将正确接收但失序的报文暂时储存起来。TCP允许接收方有选择地确认失序报文段，而不是累计地确认最后一个正确接收的有序的报文段。这一点采用的是SR的实际思路。

   因此TCP差错机制是GBN与选择重传协议的混合体。

10. 加倍超时间隔：每次超时时间发生时，下一次的**超时间隔**会被设为当前超时间隔的两倍，而不是由EstimatedRTT和DevRTT推出，这也提供了一种有限形式的拥塞控制。
11. 快速重传：发送方可以在超时事件发生前通过注意**冗余ACK**来检测丢包情况。如果发送方接收到相同数据的三个冗余ACK，则就认为已被确认三次的报文之后的报文已经丢失，执行快速重传。

### 3.5.5 流量控制

10. TCP提供流量控制服务(flow-control service)**以消除发送方使得接收方缓存溢出的可能**，不同于拥塞控制(congestion control)，**二者动作类似，但针对不同的原因。**

11. 发送方维护一个叫接收窗口的变量，该变量告诉发送方接收方还有多少缓存空间可用。（连接两端的发送方各维护一个接受窗口，接收窗口随时间而变化，满足

    **RcvWindow = RcvBuffer - [LastByteRcvd - LastByteRead]**

    对于发送端的两个变量：LastByteSent, LastByteAcked，前者减后者得到的差为发送端发送但还未被确认的数据量，通过**将该数据量控制在RcvWindow以内，可以保证发送端不会使接收端缓冲区溢出**。

12. RecWindow时的特殊处理：当接收端接收窗口为0时，发送端继续发送一个只有一个字节数据的报文段，等到该报文段被接收方确认时，返回确认报文里包含非零的RcvWindow。

### 3.5.6 TCP连接管理

如何创建和删除一条TCP连接。

13. 建立TCP连接：三次握手
    1. 客户机向服务器的TCP发送一个特殊的TCP报文段，首部标志位SYN置为1，客户机会选择一个起始序号(client_isn)，并将其放置到该起始的TCP SYN报文段中，该报文段被封装在一个IP数据报中，发送给服务器。
    2. 一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器会提取TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向客户端发送允许链接的报文段，该报文段不含应用层数据，SYN置位1，确认号字段被设为client_isn + 1。最后，服务器选择自己的初始序号server_isn，并将其放置在TCP报文首部的序号字段中。该报文段有时称为SYNACK报文段。
    3. 客户机收到SYNACK报文段后，客户机给连接分配缓存和变量，还会向服务器发送另外一个报文段，将确认字段赋值为server_isn + 1，SYN置为0。
14. 断开TCP连接：FIN置1的报文段发送给另一方，另一方收到后返回确认报文段（ACK），然后另一方也发送FIN为1的终止报文段，并等待确认报文段回复，确认完毕后，两台主机上的对应的资源都被释放了。
15. RST标志位的使用：告诉一台主机，"你要的套接字我没有，不要再给我发送了。"

## 3.6 拥塞控制原理

### 3.6.1 拥塞的原因和开销

1. 拥塞网络的开销：
   1. 分组到达速率接近链路容量时，分组经历的巨大排队延时
   2. 发送方必须执行重传以补偿因为缓存溢出而丢失的分组
   3. 发送方遇到大延时时所进行的不必要的重传会引起路由器利用其链路来转发不必要的分组拷贝
   4. 一个分组沿着一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该的分组而使用的传输容量被浪费掉了。

### 3.6.2 拥塞控制方法

2. 端到端拥塞控制：（网络层不提供支持）端系统通过观察网络行为来推断网络状况。
3. 网络辅助的拥塞控制：网络层组件（路由器）向发送方提供关于网络中拥塞状态的显示返回信息（如，拥塞分组或路由器更新分组的某个字段）。

### 3.6.3 网络辅助的拥塞控制案例：ATM，ABR拥塞控制*

## 3.7 TCP拥塞控制

如果一个TCP发送方感知从它到目的地之间的路径上无拥堵，则发送放会增加速率，否则降低速率。

1. TCP拥塞机制让链接的每一个端都记录一个额外的变量，即**拥塞窗口**(Congestion Window)，CongWin，**用于限制一个发送方向网络发送是流量的速率**，并满足一个发送方中未确认的数据量不超过CongWin和RcvWindow。暂时忽略RcvWindow，当丢包事件发生后（三个冗余ACK），则暗示出现了拥塞。

三个TCP拥塞控制算法：

1. AIMD **加性增，乘性减** ：**丢包事件发生后，让CongWin减半**，以MSS为单位，单次发送不得少于一个MSS。**不丢包则缓慢增加拥塞窗口的长度**（每次增加一个MSS），谨慎地探测端到端路径上额外的可用宽带。发送的方式一般是一次发送多个报文段来实现发送速率的增加（增长增长阶段被称为**拥塞避免 CA**）。
2. SS 慢启动：当一个TCP连接开始时，CongWin的初始值设置为1个MSS，即初始传输速率为MSS/RTT， **每过一个RTT将CongWin翻倍，直到发生一个丢包事件，降到一半并从此线性增长。**

3. 对超时时间作出反应：发生超时时，TCP发送方进入一个慢启动阶段，CongWin被置为1，开始成倍增加。
   1. TCP通过维持一个阈值Threshold来管理这些比较复杂的动态过程，它是用来确定慢启动将结束并且拥塞避免将开始的窗口长度。该变量初始化时设置为一个很大的值（65KB)，每当丢包事件发生时，该变量被设置为CongWin的一半，并将该值维持到下一个丢包为止。
   2. 一些版本的TCP（Reno)在收到三个冗余ACK事件后会取消慢启动阶段（直接进入拥塞避免阶段），称为快速恢复。
4. 对TCP吞吐量的宏观描述：一个连接的平均吞吐量 = 0.75 times W / RTT，W表示窗口字节长度。还有一个 一个连接的平均吞吐量 = 1.22 times MSS times sqrt(L) / RTT，L表示丢包率、**RTT为往返时间、MSS为最大报文长度**。

5. 公平性：每条链接都能得到相同份额的宽带链路，则认为这个拥塞控制机制是公平的。理想情况下，拥塞避免是公平的；UDP是不公平的；TCP不能阻止一个TCP应用同时使用多条并行链接。