# Part06 Designing Objects with Responsibilities 基于职责设计对象

[toc]

## Chap17 GRASP：基于职责设计对象

1. **职责驱动设计（RDD）：考虑怎样给协作中的对象分配职责，职责是类元的契约或义务。**

   **职责分为两类：行为和认知。**

   在思考软件对象的设计时，考虑其职责、校色和协作

2. 对象的行为职责：
   1. 自身执行一些行为，如计算或创建对象
   2. 初始化其他对象中的动作
   3. 控制和协调其他对象的活动
3. 对象的认知职责：
   1. 对私有封装数据的认知
   2. 对相关对象的认知
   3. 对其能够导出或计算出的事物的认知
4. 职责、GRASP、UML图之间的联系：绘制UML图时，就是在决定职责的分配，GRASP中的基本原则能够知道在分配时可以做出的选择。
5. **模式（pattern）：对问题和解决方案的已命名描述**。
6. GRASP共包含9个模式，本章介绍其中5个：创建者、信息专家、低耦合、控制器、高内聚。

---

### GRASP

* **名称：Creator 创建者**
  * **问题：谁创建了A？**
  * 解决方案：如果以下条件为真时（越多越好），将创建类A实例的职责分配给类B：
    * B“包含”或组合聚集了A。
    * B记录A。
    * B紧密地使用A。
    * B具有A的初始化数据。
  * 优点：支持低耦合，具有较低的维护依赖性和较高的复用性。

* **名称：Information Expert 信息专家**
  * **问题：给对象分配职责的基本原则是什么？**
  * 解决方案：**把职责分配给具有完成该职责所需信息的那个类**，信息包括关于其他对象的信息、对象自身的状态、对象周围的环境、对象能够导出的信息等等。
  * 优点：
    * 维持信息的封装性，支持低耦合，形成健壮可维护的系统
    * 支持高内聚、更容易理解和维护。
* **名称：Low Coupling 低耦合**
  * **问题：如何减少因变化产生的影响？**
  * 解决方案：**分配职责以使不必要的耦合保持在较低水平，用该原则对可选方案进行评估**。
  * 优点：
    * 不受其它构件变化的影响
    * 易于单独理解
    * 便于复用
* **名称：Controller 控制器**
  * **问题：在UI层之上首先接收和协调系统操作的对象是什么？**
  * 解决方案：把职责分配给能代表下列选择之一的对象：
    * **能够代表全部”系统“、“根对象”、运行软件的设备或主要的子系统**（外观控制器的变体）
    * **代表发生系统操作的用例场景**（用例或会话控制器）
  * 优点：
    * 增加了可复用和接口可插拔的能力
    * 获得了推测用例状态的机会

* **名称：High Cohesion 高内聚**
  * **问题：怎样使得对象保持有内聚、可理解和可管理，同时具有低耦合的附加作用？**
  * 解决方案：**职责分配应该保持高内聚，以此来评估备选方案。内聚是元素职责的相关性和集中度的度量。**如果元素具有高度相关的职责，并且没有过多的工作，那么该元素具有高内聚性。
  * 优点：
    * 易于理解
    * 简化维护和改进工作
    * 通常支持低耦合
    * 细粒度、相关性强的功能重用性增加

---

## Chap18 GRASP设计示例

1. **用例实现（use-case realization）：描述某个用例基于协作对象如何在设计模式中实现**

## Chap19 对可见性进行设计 

1. **可见性（visibility）：是指对象看到或引用其他对象的能力。**可见性的动机是为了使对象A能够向B发送消息，对于A而言，B必须是可见的。
2. 四种可见性：
   1. 属性可见性：B是A的属性
   2. 参数可见性：B是A中某方法的参数
   3. 局部可见性：B是A某方法中的局部对象
   4. 全局可见性：B具有某种方式的全局可见性

## Chap20 将设计映射为代码

1. 设计映射到代码：面向对象语言需要为类和接口的定义和方法的定义编写源代码

2. 实现的顺序：按照从耦合度最低到耦合度最高的顺序来完成

   ![image-20210712161812123](C:\Users\17727\AppData\Roaming\Typora\typora-user-images\image-20210712161812123.png)

3. **测试驱动开发（TDD）和测试优先开发（test-first development）**：**测试代码之前要完成单元测试代码的编写，同时要开发所有产品代码编写单元测试代码。**基本规律是：测试代码与产品代码交替进行，每次需要保证产品代码能通过测试。**先写测试代码再写单元代码。**

## Chap21 测试驱动开发和重构

1. TDD的优点：
   1. 能够保证编写单元测试
   2. 是程序员获得满足感以坚持变成
   3. 有助于澄清接口和行为的细节
   4. 可证明、可在线、自动地验证
2. 测试的基本模式：
   1. 创建测试固件（被测试的事物）、
   2. 对其完成某些操作
   3. 评估结果是否为期望值

3. 重构（refactoring）：重写或重新构建已有代码的结构化和规律化的方法，但不会改变已有代码的外在行为。重构的本质是一次实行一次保留行为的转换，转换后重新执行单元测试，以保证无误。

4. 重构的目的：为了得到更优秀的代码（简短、清晰、紧凑的代码）

   1. 去除冗余代码
   2. 改善清晰度
   3. 缩短过长的方法
   4. 取出硬编码的字面常量

5. 重构样例：

   ![image-20210712163922097](C:\Users\17727\AppData\Roaming\Typora\typora-user-images\image-20210712163922097.png)

## Chap25 GRASP：更多具有职责的对象

**多态（Polymorphism）、间接性（Indirection）、纯虚构（Pure Fabrication）、防止变异（Protected Variation）**

1. **多态（Polymorphism）：**

   * **问题：如何处理基于类型的选择？如何创建可插拔的软件构件？**

   * 解决方案：**当相关选择或行为类型有所不同时，使用多态操作为变化的行为分配职责。**

   * 优点：
     * 易于增加新变化所需的扩展
     * 无需影响客户便能引入新的实现

2. **纯虚构（Pure Fabrication）：**

   * 问题：当你不想违背高内聚和低耦合以及其他目标，单基于专家模式提供的方案又不合适时，那个对象应该承担这一职责？
   * 解决方案：对**人为制造的类**分配一组高内聚的职责，该类并不代表问题领域的概念，虚构的事物用以支持高内聚、低耦合和复用。
   * 优点：
     * 支持高内聚，因为职责被解析为细粒度的类，这种类只着重与极为特定的一组相关任务。
     * 增加了潜在的复用性

3. **间接性（Indirection）：**

   * 问题：**为了避免两个或多个事物直接耦合，应该如何分配职责？**如何是对象解耦合，以支持低耦合并提供服用潜力？
   * 解决方案：**将职责分配给中介对象，使其作为其他构件与服务之间的媒介**，以避免他们直接耦合。
   * 优点：实现了构件之间的低耦合。

4. **防止变异（Protected Variation）：**
   * 问题：**如何设计对象、子系统和系统，使其内部变化或不稳定因素不会对其他元素产生不良影响？**
   * 解决方法：**识别预计变化或不稳定之处，分配职责用以在这些变化之外创建稳定接口**（访问视图）。
   * 优点：
     * 易于增加新变化所需要的扩展
     * 可以引入新的实现而无需影响客户
     * 低耦合
     * 降低变化的成本和影响

---





