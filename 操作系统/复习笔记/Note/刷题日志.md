# 刷题区

## 1 引言

选择题：3、7、8、10

填空题：5、7、9、10、12、14、17、18、19

## 2 作业与进程管理

A(<font color='red'>C</font>) B C D A

B C C C D

B D D B(<font color='red'>D</font>) B(<font color='red'>A</font>)

C C D B A

B B C B C

D **07031507 - 22/25**

非多道：60 + 90 = 150

多道：(18 + 27) / 50% + 15 = 105

系统效率提高量的计算 = 45 / 150  = 30%

---

多道程序设计系统中，让多个计算问题同时装入计算机系统的主存储器**并行执行**

对于一个单处理器系统来说，允许若干进程同时执行，轮流占用处理器，称它们为**并发执行**的

---

**临界区**：每个进程中访问临界资源的那段代码称为临界区

**相关临界区**：多个进程中涉及到同一个临界资源的临界区称为相关临界区。

---

管理若干进程共享某一资源的相关临界区应满足三个要求：（**互斥、进步、有限等待**）

* **任何进程不应该无限地逗留在它的临界区中**
* **一次最多让一个进程在临界区执行**
* **不能强迫一个进程无限地等待进入它的临界区**。

---

## 3 进程调度与死锁

B A A B B

A C B A C

A(<font color='red'>D</font>) B D(<font color='red'>B</font>) D D

B(<font color='red'>C</font>) A(<font color='red'>B</font>) D A D(<font color='red'>C</font>)

A(<font color='red'>D</font>) 07031557 - 15/21

---

**1** 普通调度题

先来先服务：PA PB PC PD 等待时间：0 20 35 45 平均为100 / 4 = 25

非抢占式的优先数：PA PB PD PC 等待时间：0 20 35 47 平均为102 / 4 = 25.5

<font color='red'>错了，优先数是默认数值高的优先，因而是 PC PD PB PA</font>

**2 多道+内存限制+I/O资源限制调度题**

先来先服务：A B C D E 平均周转时间（平均等待时间）(0 + 0 + 15 + 10 + 25) / 5 = 10

计算时间最短者优先：A B E D C 平均周转时间 (0 + 0 + 0 + 5 + 20) / 5 = 5 

<font color='red'>救命，全错了，好难，诸多因素没考虑</font>

* **做题方法：仿照下面那一个表格，可能还需要各个时间节点的内存空闲空间分布图**

* **首先，多道程序不等于多线程执行，因此一个时间只能运行一个作业**

* 本题中，我们要区分以下时间：**进入输入井的时间**、**装入主存的时间**、**开始执行的时间**、**结束执行的时间**

* **周转时间 = 执行结束的时间 - 进入输入井的时间**

* **执行作业的顺序，指作业开始执行的时间**

* 载入内存的前提是内存空间足够和空闲磁带机足够？

* **主存空间的进程不能移动，产生碎片！！！**

* 先来先服务 

  * **时间线**

    * 8:30 A和8:50 B先被装入主存
    * 9:00 C到达输入井，但主存空间不够，等待
    * 9:05 D到达输入井，主存空间足够，但磁带机不够，等待
    * 9:10 A执行结束，E到达输入井，B开始执行，此时内存空间为两块(30,50)，磁盘机有4台。C，D，E都有机会装入主存：而内存空间不足以容下C，C等待；D进入主存，此时内存空间为两块(30,30)（这里可以有个分支，即10,50，因主存分配算法不同而不同），E因为内存空间的碎块而无法进入主存，等待。
    * 9:35 B执行结束，D开始执行，此时内存空间为两块(150,30)，磁带机有2台。对于C，内存允许，磁带机足够，C进入主存，内存空间变为两块(50,30)，D还是无法进入内存空间。
    * 9:55 D执行结束，C开始执行，此时内存空间为两块(50,50)，E还是没能进入主存
    * 10:30 C执行结束，现在只剩E了，E装入，执行。

  * **调度表**

    | 作业名 | 进入输入井时间 | 装入主存时间 | 开始执行时间 | 执行结束时间 | 周转时间 |
    | ------ | -------------- | ------------ | ------------ | ------------ | -------- |
    | A      | 8:30           | 8:30         | 8:30         | 9:10         | 40       |
    | B      | 8:50           | 8:50         | 9:10         | 9:35         | 45       |
    | C      | 9:00           | 9:35         | 9:55         | 10:30        | 90       |
    | D      | 9:05           | 9:10         | 9:35         | 9:55         | 50       |
    | E      | 9:10           | 10:30        | 10:30        | 10:40        | 90       |

  * 执行顺序因而是：A B D C E，平均时间为 315 / 5 = 63。

* 计算时间最短者优先（自己尝试一下）

  * 时间线

    * 8:30 A进来了，此时磁带机数剩余3台，主存剩余170
    * 8:50 B进入输入井，内存和磁带机数满足B要求，B进入主存，主存剩余50
    * 9:00 C进入输入井，主存空间和磁带机不足，等待
    * 9:05 D进入输入井，磁带机不足，等待
    * 9:10 A执行结束，B开始执行，此时主存空间为(30,50)，E进入输入井，比较C,D,E计算时间，先考虑E，内存空间不足，等待；在考虑D，磁带满足，内存空间满足，载入内存，此时内存空间为(30,30)*，C空间不足，等待。
    * 9:35 B执行结束，D开始执行，此时主存空间为(150,30)，先考虑E，内存和磁带机足够，载入内存，主存空间变为(90,30)，C等待
    * 9:55 D执行结束，E开始执行，此时主存空间为(90,50)，主存空间不足以满足C载入内存，C等待
    * 10:05 E执行完毕，C载入内存并开始执行 

  * 调度表

    | 作业名 | 进入输入井时间 | 载入内存时间 | 开始执行时间 | 结束执行时间 | 周转时间 |
    | ------ | -------------- | ------------ | ------------ | ------------ | -------- |
    | A      | 8:30           | 8:30         | 8:30         | 9:10         | 40       |
    | B      | 8:50           | 8:50         | 9:10         | 9:35         | 45       |
    | C      | 9:00           | 10:05        | 10:05        | 10:40        | 100      |
    | D      | 9:05           | 9:10         | 9:35         | 9:55         | 50       |
    | E      | 9:10           | 9:35         | 9:55         | 10:05        | 55       |

  * 结果：执行顺序因而是：A B D E C，平均时间为 290 / 5 = 58。<font color='red'>对了，Hiahia</font>

**3 和上一题差不多的，不写了** 

**4 银行家算法** 安全序列（不懂怎么做）

假设先满足了$P_2$的要求，此时需求量状况为：

| 进程 | 已占资源数 | 最大需求量 | 还可申请资源数 |
| ---- | ---------- | ---------- | -------------- |
| P1   | 3          | 7          | 4              |
| P2   | 5          | 8          | 3              |
| P3   | 2          | 3          | 1              |

借助银行家算法，判断他是否为安全状态：A = 0, W = 0, F = [f,f,f], N = [4,3,1], M = [7,8,3], Al = [3,5,2]，算法直接退出了，显示此时不是安全状态，因此不应该先满足P2的要求

P3 P1 P2比较合适，因为首先P3，会进入安全状态，响应P1请求后，仍处于安全状态

<font color='red'>**答案如下：**</font>

<font color='red'>（1）根据表，若把资源分配给P2，则系统已经无资源可以继续分配，**此时每个进程都在等待资源**，形成死锁（终于明白了，所以整个安全序列的过程只是一个在小心翼翼地分配资源的过程），所以不能先满足P2的要求。</font>

<font color='red'>（2）可以先为P3分配一个资源，当它归还3个资源后，便有了4个可分配资源，可以先满足P1请求，分配4个给P1，随后当它归还4个资源后，最后把资源分配给P2。（**你要知道分配全后，该进程就可正常执行，随后返还所有资源**）</font>

**5 银行家算法**

<font color='red'>**本质上就是跑算法，安全检测是一个算法，每次资源请求后需要调用安全检测判断是否存在安全序列。**</font>

Av = [2,6,2,1], Al = [[3,6,2,0], [1,0,2,0], [1,0,4,0], [0,0,0,1], [5,3,4,1]], M = [[5,6,2,0], [1,0,2,0], [5,6,6,0],[5,7,0,1], [5,3,6,2]], Need = [[2,0,0,0], [0,0,0,0], [4,6,2,0], [5,7,0,0], [0,0,2,1]] 

初始化 W = [2,6,2,1], F = [0,0,0,0,0]

第一步 i = 0, W = [5,12,4,1], F = [1,0,0,0,0]

第二步 i = 1, W = [6,12,6,1], F = [1,1,0,0,0]

第三步 i = 2, W = [7,12,10,1], F = [1,1,1,0,0]

第四步 i = 3, W = [7,12,10,2], F = [1,1,1,1,0]

第五步 i = 4, W = [12,15,14,3], F = [1,1,1,1,1]

所以目前系统属于安全状态，**此处应给出安全序列 0 1 2 3 4**

RD = [2,5,0,0]，调用资源请求算法

[2,5,0,0] < [5,7,0,1]

[2,5,0,0] < [2,6,2,1]

Av = [0,1,2,1], Al =  [[3,6,2,0], [1,0,2,0], [1,0,4,0], [2,5,0,1], [5,3,4,1]], N = [[2,0,0,0], [0,0,0,0], [4,6,2,0], [3,2,0,0], [0,0,2,1]] 

在调用安全算法：

初始化 W = [0,1,2,1], F = [0,0,0,0,0]

第一步 i = 1, W = [1,1,4,1], F = [0,1,0,0,0]

第二步 i = 4, W = [6,4,8,2], F = [0,1,0,0,1]

第三步 i = 0, W = [9,10,10,2], F = [1,1,0,0,1]

第四步 i = 2, W = [10,10,14,2], F = [1,1,1,0,1]

第五步 i = 3, W = [12,15,14,3], F = [1,1,1,1,1]

目前系统仍属于安全状态，**此处应给出安全序列 1 4 0 2 3**（和答案一致）

**6 死锁证明**

因为当n个进程最多需要小于(m+n)时，属于安全序列，不会发生死锁。

<font color = red>证明：设n个进程请求的最大资源量时$x_i,\sum x_i < m $</font> 

<font color = red>资源最坏申请的情况是每个进程都已经得到了$x_i - 1$个资源，因为$\sum x_i + 1 <= m $，系统至少还有一个资源可以满足某个进程，等它归还后就可提供给其他进程使用，不会发生死锁。</font> 

---

进程调度：

* **响应比**最高者优先算法：在进行作业调度时，要想兼顾作业等待时间和计算时间，应选取响应比最高者优先算法
* **相应比**：作业调度算法提到的响应比是指**作业等待时间与计算时间之比**

---

死锁的必要条件：互斥、等待并占有、非抢占、循环等待同时成立

---

死锁的处理方法：防止、避免和检测

* 死锁的防止是根据**破坏产生死锁的四个必要条件之一**采取措施实现的。

* 采用按序分配资源的策略可以防止死锁，这是利用了使 **循环等待资源**条件不成立。
* 实际的操作系统要兼顾资源的使用效率和安全可靠，对资源的分配策略，往往采用**死锁的防止、避免和检测的混合**

---

银行家算法原理

* 安全状态：存在一个安全序列

* **安全序列是什么 - 进程序列$<p_1, p_2, ... p_n>$在当前分配状态下为安全序列，是指：对于每个$p_i$，$p_i$仍然可以申请的资源数小于当前可用的资源加上所有进程$p_j(j < i)$所占有的资源**

* 用银行家算法避免死锁时，检测到**进程已占用的资源数与本次申请的资源数之和不超过对资源的最大需求量**，且**现存资源能满足尚需的最大资源量**时才分配资源
* 检测当前系统是否安全的安全算法
* 判断是否安全允许请求的算法

---

## 第四章 储存管理

C B D B D

A D C B A

C C B D A

B B A B D

D B(<font color='red'>D</font>) C A B

C B B(<font color='red'>B</font>) D C

B B D C D

A(<font color='red'>C</font>) A A 07032058 - 35/38

---

**1 可变分区 内存分配 计算内存利用率**

<font color='red'>内存利用率这里也没怎么算，就是这些主存最多能装入的作业 / 作业总数吧</font>

最先适应分配算法：

第一步 10  - 5 28 10 226 110

第二步 15  - 5 13 10 226 110

第三步 102 - 5 13 10 124 110

第四步 26  - 5 13 10 98 110

第五步 80  - 5 13 10 18 110

能按Ja - Je的次序全部装完 

最优适应分配算法：

第一步 10 - 15 28 226 110

第二步 15 - 28 226 110

第三步 102 - 28 226 8

第四步 26 - 2 226 8

第五步 80 - 2 146 8

最坏适应算法：

第一步 10 - 15 28 10 216 110

第二步 15 - 15 28 10 201 110

第三步 102 - 15 28 10 99 110

第四步 26 - 15 28 10 99 84

第五步 80 - 15 28 10 99 80

**2 页面调度**

FIFO：缺页共13次，缺页率65%。

| 1    | 1    | 1    | 1    | 1    | 0    | 1    | 0    | 0    | 0    | 1    | 1    | 0    | 1    | 1    | 0    | 0    | 1    | 1    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 7    | 0    | 1    | 2    | 3    | 3    | 4    | 4    | 4    | 4    | 6    | 7    | 7    | 1    | 5    | 5    | 5    | 2    | 6    | 7    |
|      | 7    | 0    | 1    | 2    | 2    | 3    | 3    | 3    | 3    | 4    | 6    | 6    | 7    | 1    | 1    | 1    | 5    | 2    | 6    |
|      |      | 7    | 0    | 1    | 1    | 2    | 2    | 2    | 2    | 3    | 4    | 4    | 6    | 7    | 7    | 7    | 1    | 5    | 2    |
|      |      |      | 7    | 0    | 0    | 1    | 1    | 1    | 1    | 2    | 3    | 3    | 4    | 6    | 6    | 6    | 7    | 1    | 5    |

LRU：缺页共12次，缺页率60%。

| 1    | 1    | 1    | 1    | 1    | 0    | 1    | 0    | 0    | 0    | 1    | 1    | 0    | 1    | 1    | 0    | 1    | 1    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 7    | 0    | 1    | 2    | 3    | 0    | 4    | 3    | 2    | 3    | 6    | 7    | 3    | 1    | 5    | 7    | 6    | 2    | 6    | 7    |
|      | 7    | 0    | 1    | 2    | 3    | 0    | 4    | 3    | 2    | 3    | 6    | 7    | 3    | 1    | 5    | 7    | 6    | 2    | 6    |
|      |      | 7    | 0    | 1    | 2    | 3    | 0    | 4    | 4    | 2    | 3    | 6    | 7    | 3    | 1    | 5    | 7    | 7    | 2    |
|      |      |      | 7    | 0    | 1    | 2    | 2    | 0    | 0    | 4    | 2    | 2    | 6    | 7    | 3    | 1    | 5    | 5    | 5    |

<font color='red'>勾，但是我们的写法和答案的不一样</font>

**3 段表 地址计算**

（1）物理地址 = 段长 + 主存初始地址

（2）1760 + 550 = 2310，1560 + 186  = 1764，1000 + 300 = 1300(<font color='red'>300 > 200越界了</font>)，2800 + 655 = 3455

<font color='red'>错了，这道题是要检查是否越界的，第一问也要说清楚。答案：)段式存储管理重定位过程为：1. 根据逻辑地址中的段号找到段表中相应表目。 2. 根据段内地址＜该段限长，确定是否越界。3. 若不越界，则 绝对地址 = 段起始地址 + 段内地址</font>

---

**最近最少用调度算法** LRU 基于堆栈的

**最近最不常用调度算法** LFU 基于计数的

---

**页式存储管理**分配主存空间时可以根据由“位示图”构成的主存分配表。

---

## 第五章 设备管理

B **A** B **D** D 

C B C A B

**D** C **B** **B** **D**

B 07032159 - 11/16

---

**1 磁盘调度算法**（还没对答案）

先来先服务调度算法：175 52 157 36 159 106 108 72

最短寻找时间算法：106 108 72 52 36 157 175 

电梯调度算法：106 108 157 175 (199) 72 52 36

单向扫描算法：106 108 157 175 72 52 36

磁臂移动距离计算：以先来先服务调度算法为：磁臂移动总距离 175-96 + 175-52 + 157-52 + 157-36 + 159-36 + 159-106 + 108-106 + 108-72 = 642

**很想知道标准答案会怎么处理**

**2 磁盘访问 - 最优策略？**

**3 计算题**



---

对存储型设备，输入输出操作的信息是**以块为单位**传输的。

对输入输出设备，输入输出操作的信息传输单位为**字符**。

---

在用户程序中通常用**设备类、相对号**提出使用设备的要求

---

**电梯调度算法 LOOK**总是从磁盘移动臂的当前位置开始沿着臂的移动方向去选择距离当前移动臂最近 的那个柱面的访问者；若沿臂的移动方向无请求访问时，就改变臂的移动方向再选择。

---

中央处理器执行用户提出的“请求启动外设”的要求时，会产生一个**自愿性中断事件**

通道在发现 CSW（信道状态字） 中有控制器结束、设备结束、通道结束、设备故障或设备特殊情况 时，会发出**输入输出中断**

---

**虚拟设备是指把共享设备模拟成独占设备**

---



## 第六章 文件管理

A A B C C

B B A C B

C A C **C(B)** C

D A A A B

A D B A C

C B C D **A(D)**

B **A(B)** **D(B)** D B 07032348-31/35

---

**1 块，成组**



**2 磁盘 位示图**





---

逻辑文件可分为流式文件和记录式两类

在随机存储方式中，用户以**数据项**为单位对文件进行存取和检索。

有的系统为了方便用户，提供一种隐式使用文件的方法，但用户对**读文件**还是必须显 式地提出

用**存取控制表**可以防止共享文件可能造成的破坏，但实现起来系统开销太大。

UNIX规定数字 4 、2 和 1表示读、写、执行权限，可相加。

---

* 常用的进程调度算法有先来先服务、优先数，时间片轮转以及分级调度等算法。

* 常用的作业调度算法有先来先服务算法、计算时间短的作业优先算法、响应比最高者优先算法、优先数调度算法和均衡调度算法。

采用计算时间短的作业优先算法，肯定能使平均周转时间最小。

响应比最高者优先算法综合考虑作业的等待时间，计算时间

作业调度与进程调度相互配合才能实现多道作业的并行执行。

使占有并等待资源的条件不成立而防止死锁常用两种方法：静态分配资源，释放已占资源

静态分配资源也称预分配资源，要求每—个进程在开始执行前就申请它需要的全部资源。

释放已占资源的分配策略是仅当进程没有占用资源时才允许它去申请资源。

银行家算法是一种古典的安全状态测试方法，用于避免死锁。

可以证明，m 个同类资源被 n 个进程共享时，只要不等式______成立，则系统一定不 会发生死锁，其中 x 为每个进程申请该类资源的最大量。n*(x-1)+1<=m

对每个资源类中只有一个资源的死锁检测程序根据占用表，等待表两张表中记录的资源 情况，把进程等待资源的关系在矩阵中表示出来，以判别是否出现死锁。

解除死锁的方法有两种，一种是终止一个或几个进程的执行以破坏循环等待，另一 种是从涉及死锁的进程中抢夺资源





块号＝字数×字长+位数

**柱面号**＝**[块号／每柱面扇区数]**

**磁头号**＝[(块号 mod 每柱面扇区数)**／每盘面扇区数]**

**扇区号**＝(块号 mod 每柱面扇区数) **mod 每盘面扇区数** 



【柱面号：磁头号（log每柱面磁道数位）：扇区号（log每磁道扇区数位）】

---

斯普林（SPOOLing）是指___联机外围设备同时操作___ 的意思。操作系统用它实现___虚拟设备___的功能。

斯普林（SPOOLing）系统由预输入程序、___井管理程序___和___缓输出程序___组成。