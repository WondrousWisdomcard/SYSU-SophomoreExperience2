## Chap08 内存管理策略

1. **硬件地址保护**：单独的进程空间保护进程不受相互影响，采用基地址寄存器和界限寄存器来实现

2. **地址绑定 Bind**：从一个地址空间到另一个地址空间的映射，如编译器将符号地址绑定到可重定位的地址，连接器将可重定位地址绑定到绝对地址

   通常，数据、指令绑定到储存器地址可以发生在各个阶段，包括：编译时（绑定绝对代码，生成可重定位代码）、加载时（绑定可重定位代码）、运行时

3. **逻辑地址和物理地址**：
   * 逻辑地址（虚拟地址）：CPU生成的地址
   * 物理地址：内存单元看到的地址
   * 内存管理单元 MMU：负责实现二者的相互映射
     * 例如使用重定位寄存器（基址寄存器）实现

4. **动态加载 Load**：一个程序只有在调用时才会从磁盘加载到内存，所有程序以可重定位加载格式保存在磁盘上

5. **动态链接 Link**：将程序链接（动态链接库，也称共享库）的过程延迟到运行时
   
   * 每个库程序的引用都有一个存根（一小段代码），用来指出如何定位内存驻留库程序，或如何从硬盘加载库
   
6. **交换**：将进程暂时从内存中交换到备份存储中，当再次执行时再掉回到内存中

   1. 交换需要考虑的因素：上下文切换时间（注意往返时间），换出进程空闲（是否等待I/O）

7. **连续内存分配**：一种分配内存的方法，每个进程位于一个连续的内存区域，与包含下一个进程的内存区域相连，允许进程的物理地址空间是非连续的

   1. 连续内存分配的内存保护：用重定位寄存器（基地址寄存器）和界限寄存器来实现

   2. 分区 Partition：将内存划分为若干分区（固定大小或者可变分区） 

   3. **动态储存发配问题**：根据一组空闲孔来分配大小为n的请求

      * 首次适应 First Fit
        * 下一次适应 Next Fit：从上一次分配位置开始选择

      * 最优适应 Best Fit

      * 最差适应 Worst Fit：分配最大的孔

   4. 内部碎片和外部碎片：前者为位于进程空间内，后者不属于进程空间

8. **分段机制 Segmentation**：内存管理方案，逻辑地址空间是由一组段构成，每个段有名称和长度，地址指定了段名称和段内偏移，逻辑地址形式为$<\text{段号},\text{偏移}>$（相加）

   * **段表**：将逻辑地址映射带到物理地址，每个条目都有**段基地址**和**段界限**

9. **分页机制 Paging**：内存管理方案，**将物理内存分为固定大小的块，称为帧或页帧，而将逻辑空间分成同样大小的块，称为页或页面**，当需要执行某个进程时，它的**页**从源处加载到内存的可用**帧**，逻辑地址形式为$<\text{页码},\text{页偏移}>$（相拼接）

   * **页表**：包含每个**页**所在物理内存的基地址
   * **帧表**：每个条目对应一个帧，以表示其空闲还是已占用

   * 优点：避免了外部碎片（因为每个空闲帧都能被分配，但产生了内部碎片）、紧缩和将不同大小内存块匹配到交换空间的问题、允许我们使用的物理内存大于CPU地址可访问的空间

   * 硬件实现：多种实现方法

     * 使用一组专用的寄存器；或将页表放在内存中，用页表基地址寄存器PTBR指向页表：访问一个字节需要两次内存访问（页表条目+字节内容），访问速率减半

     * **快表**：（是一种交换机制）转换表缓冲区TLB是关联的高速内存，TLB中每一项由键（标签）和值组成（<\text{页码},\text{帧码}>）。

       * TLB使用方法：TLB包含少数页表条目，当CPU产生一个逻辑地址后，**页码**发送到TLB，若在TLB中找到，帧码则立即可用，访问内存；若找不到（TLB miss未命中），则访问页表，取得帧码来访问内存，并替换进到TLB中（替换策略：最近最少使用替换LRU、轮转替换、随机替换）

       * 地址空间标识符ASID，表示进程以保护进程地址空间

       * **命中率**：在TLB中查找到目标页码次数的百分比

       * TLB范围：TLB条数与页面大小的乘积

       * **有效内存访问时间**：
     
         有效访问时间分为第一次访问内存时间（即查找页表对应的页表项所消耗的时间t）与第二次访问内存时间（即将页表项中的物理块号与页内地址拼接成实际物理地址所耗费的时间t）之和：
         ***ETA = t + t = 2t***
         在 **引入快表的分页存储管理** 方式中：通过查询快表可直接得到逻辑页所对应的物理块号，由此拼接形成实际物理地址，减少了一次访问内存，缩短了进程访问内存的有限时间。
         ***ETA = α x λ + ( t + λ )( 1 - α ) + t = 2t + λ - t x α***
         **其中** λ ：表示查找快表所需的时间
         　　 α ：表示查找时的命中率
         t ：表示访问一次内存所需要的时间
     
       * **有效内存访问时间例题**：一具有快表的分页系统中，逻辑地址访问内存的时间是100毫秒，访问快表的时间是20毫秒，问：设从快表中查找到所需页表项的概率为85%，计算CPU存取一个数据时的有效访问时间。
         $ETA=αλ+(t+λ)(1-α)+t=20*0.85+(100+20)(1-0.85)+100=135$

     * 帧保护位：保存在页表中，可设置为有效位或无效位
     
     * 共享页：要求页内代码是可重入代码或纯代码 - 在执行期间不会自我修改

10. **页表的组织结构**：分层页表、哈希页表、倒置页表

    * 两层页表：将页表再分页，得到外部页表、页表（内部页表）、页面偏移，外部页表将映射到一个指定的页表，地址转换由外向内。
    * 哈希页表：常用于处理大于32位的地址空间，采用虚拟页码作为哈希值。哈希页表每一个条目都包含一个链表，每个元素包含虚拟页码、映射的帧码、指向下一个元素的指针。

## Chap09 虚拟内存管理

1. 请求调页：在需要时，将页面从磁盘上加载到内存。页面只有再程序执行期间被请求时才会被加载。

2. 缺页错误：发生在进程试图访问为调入内存的页面时。

3. 请求调页内存的**有效访问时间** = 缺页错误概率 * 缺页错误时间 + （1-缺页错误概率）* 内存访问时间

4. **缺页错误导致以下动作**：
   1. 陷入操作系统
   2. 保存用户寄存器和进程状态
   3. 确定中断是否为缺页中断
   4. 检查页面引用是否合法，并确定页面的磁盘位置
   5. 从磁盘中读取页面到空闲帧：
      1. 在磁盘队列中等待，直到请求被处理
      2. 等待磁盘的寻道时间或延迟时间
      3. 开始传输磁盘页面到空闲帧
   6. 在等待时，将CPU分配给其他用户（CPU调度，可选）
   7. 收到来自I/O的中断（I/O完成）
   8. 保存其他用户的寄存器和进程状态
   9. 确认中断是来自上述磁盘的
   10. 修正页表和其他表，以表示所需页面现在已经在内存中了
   11. 等待CPU再次分配给此进程
   12. 恢复用户寄存器、进程状态和新页表，在重新执行中断指令
   
5. **缺页错误处理的三个主要部分**：处理缺页错误中断、读入页面（换出加换入）、重新启动进程

6. **写时复制**：绕过请求调页，允许父进程和子进程最初共享页面，任何一个进程写入共享页面，那么就创建共享页面的副本（谁改谁拿副本）。它快速地创建进程并最小化必须分配给新创建的进程的新页面的数量
   * 页面池
   
7. **页面置换**：如果没有空闲帧，则查找当前一个为在使用的帧并释放它。是缺页错误处理程序的一部分。页面置换考虑了调入和调出，加倍了缺页错误处理时间
   * 脏位（修改位）：每个页面、帧有一个修改位，当页面内容被写入时，修改位置1当选择页面进行置换时，检查修改位，如果未修改则不换出到硬盘而是直接覆盖，以减少页面置换开销
   
8. **页面置换算法**：我们想要缺页错误率低的算法。
   * FIFO页面置换：先进先出，队列实现
   * OPT最优页面置换：考虑未来，置换最长时间不会使用的页面
   * LRU页面置换：最近最少使用算法，将每个页面与它上次被使用的时间关联起来，换出最长时间没被使用的页面。实现方法：计数器、堆栈，都难以实现/慢
   * 近似LRU页面置换：借助引用位
     * 额外引用位算法：为页表的每个页面分配8位字节，定时器中断定期将每个页面的引用位移动到其8字节的高位，其他位右移1，丢弃最低位，这些8节移位寄存器包含近8个周期内的页面使用情况，8字节转换为整数后，编号最小的替换出去
     * 第二次机会算法：当选择了一个页面，检查其引用位，为0则替换，为1则置位0继续向前搜索，可通过循环队列实现
     * 增强型第二次机会算法：通过将引用位和修改位作为有序对，多次循环，找到最佳的页面置换（最近没有使用且没有修改）
   * 基于计数的页面置换：为每一个页面引用次数保存一个计数值（代价昂贵、不实用）
     * LFU最不经常使用：置换具有最小计数的页面
     * MFU最经常使用：最小计数页面可能刚刚被引入且尚未使用
   * 页面缓冲算法：引入一个空闲帧池，被替换后，将一个空闲帧池的帧分配给新需要的线程，被替换的可以写回磁盘，无需等待页面换出，加快了页面写入的速率
   
9. **帧分配算法**：多个进程在内存中，需决定为每个进程分配多少帧

   * 分配的最小帧数：操作系统帧总数。随着分配给每个进程的帧数量减少，缺页错误率增加
   * 分配算法：平均分配、比例分配、考虑优先级
   * 全局置换与局部置换：前者可以从所有帧中选择进行替换，后者要求只能从被分配的帧种进行选择

10. **系统抖动**：高度的页面调度活动，如果一个进程调页时间大于它的执行时间

    * 多道程度高到一定程度时，开始发生抖动，CPU利用率急剧下降
    * 限制抖动的方案：抖动发生后，采用局部置换算法或优先级置换算法
    * 工作集模型
    * 控制缺页错误频率：也是一种防止都懂的策略，若缺页错误率超过上限，则为进程多分配一帧，若低于下限，则释放一帧

11. **内存映射文件**：将文件I/O作为常规内存访问，允许一部分虚拟内存与文件进行逻辑关联

12. 分配内核内存：当在用户模式下运行进程请求额外内存时，从内核维护的空闲帧列表上分配页面。以下两策略用于管理内核线程的空闲内存
    * 伙伴系统

      ![image-20210701090205140](C:\Users\17727\AppData\Roaming\Typora\typora-user-images\image-20210701090205140.png)

    * slab分配

13. 其他的大概看看书就好了